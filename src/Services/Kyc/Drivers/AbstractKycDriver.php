<?php

// File: src/Services/Kyc/Drivers/AbstractKycDriver.php
namespace Saman9074\IranianValidationSuite\Services\Kyc\Drivers;

use Illuminate\Http\Client\Factory as HttpFactory;
use Illuminate\Http\Client\Response as IlluminateResponse;
use Saman9074\IranianValidationSuite\Services\Kyc\Responses\KycDriverResponse;
use Saman9074\IranianValidationSuite\Exceptions\Kyc\KycConnectionException;
use Saman9074\IranianValidationSuite\Exceptions\Kyc\KycAuthenticationException;
use Saman9074\IranianValidationSuite\Exceptions\Kyc\KycInvalidResponseException;
use Saman9074\IranianValidationSuite\Exceptions\Kyc\KycException;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\Client\PendingRequest;

/**
 * Class AbstractKycDriver
 * Provides common functionality for KYC drivers.
 */
abstract class AbstractKycDriver
{
    protected array $config;
    protected HttpFactory $httpClientFactory;
    protected string $providerName;

    public function __construct(array $config, HttpFactory $httpClientFactory)
    {
        $this->config = $config;
        $this->httpClientFactory = $httpClientFactory;
        $this->providerName = $config['provider_name'] ?? 'unknown_kyc_provider';
    }

    protected function getConfigValue(string $key, $default = null)
    {
        return $this->config[$key] ?? $default;
    }

    protected function getBaseUrl(): string
    {
        return rtrim($this->getConfigValue('base_url', ''), '/');
    }

    protected function makeRequest(string $method, string $endpoint, array $options = []): IlluminateResponse
    {
        /** @var PendingRequest $client */
        $client = $this->httpClientFactory->baseUrl($this->getBaseUrl());
        $method = strtolower($method);

        $actualHeaders = [];

        if (isset($options['headers'])) {
            $client = $client->withHeaders($options['headers']);
            $actualHeaders = array_merge($actualHeaders, $options['headers']);
        }
        if (isset($options['token'])) {
            $client = $client->withToken($options['token']);
            $actualHeaders['Authorization'] = 'Bearer ' . $options['token'];
        }

        $timeout = $options['timeout'] ??
                     $this->getConfigValue(strtolower($method) . '_timeout',
                         $this->getConfigValue('timeout', 30)
                     );
        $client = $client->timeout($timeout);

        $requestDataForLog = $options['data'] ?? [];
        $jsonDataForLog = $options['json'] ?? null;
        $formParamsForLog = $options['form_params'] ?? null;
        $multipartPartsForLog = [];

        if (isset($options['multipart'])) {
            foreach ($options['multipart'] as $part) {
                $logContent = $part['contents'];
                if (is_resource($logContent) && get_resource_type($logContent) === 'stream') {
                    $logContent = "STREAM_RESOURCE(Filename:{$part['filename']})";
                } elseif (!is_string($logContent) && isset($part['filename'])) {
                     $logContent = "FILE_CONTENTS(Filename:{$part['filename']})";
                }
                $multipartPartsForLog[$part['name']] = isset($part['filename']) ? "FILE:{$part['filename']} (Content: {$logContent})" : $part['contents'];
            }
            $actualHeaders['Content-Type'] = 'multipart/form-data; boundary=... (auto-generated by Guzzle)';
        } elseif (isset($options['json'])) {
            $actualHeaders['Content-Type'] = 'application/json';
            $actualHeaders['Accept'] = 'application/json';
        } elseif (isset($options['form_params'])) {
            $actualHeaders['Content-Type'] = 'application/x-www-form-urlencoded';
        }

        Log::debug("{$this->providerName} KYC Request Details (Preparing):", [
            'method' => strtoupper($method),
            'url' => $this->getBaseUrl() . $endpoint,
            'headers_to_be_sent' => $actualHeaders,
            'query_params_or_general_data' => $requestDataForLog,
            'json_payload' => $jsonDataForLog,
            'form_params_payload' => $formParamsForLog,
            'multipart_parts' => $multipartPartsForLog,
            'timeout_seconds' => $timeout
        ]);

        $requestData = $options['data'] ?? [];

        try {
            if (isset($options['json'])) {
                $response = $client->asJson()->{$method}($endpoint, $options['json']);
            } elseif (isset($options['form_params'])) {
                $response = $client->asForm()->{$method}($endpoint, $options['form_params']);
            } elseif (isset($options['multipart'])) {
                $clientWithAttachments = $client;
                foreach ($options['multipart'] as $attachment) {
                    if (isset($attachment['name']) && isset($attachment['contents'])) {
                        $clientWithAttachments = $clientWithAttachments->attach(
                            $attachment['name'],
                            $attachment['contents'],
                            $attachment['filename'] ?? null,
                            $attachment['headers'] ?? []
                        );
                    }
                }
                $response = $clientWithAttachments->{$method}($endpoint, $requestData);
            } else {
                $response = $client->{$method}($endpoint, $requestData);
            }

            Log::debug("{$this->providerName} KYC Response Status: {$response->status()}", [
                'response_headers' => $response->headers(),
                'body_snippet' => substr($response->body() ?? '', 0, 1000) . (strlen($response->body() ?? '') > 1000 ? '...' : '')
            ]);

            if ($response->status() === 401 || $response->status() === 403) {
                $errorBody = $response->json() ?? $response->body();
                $errorMessage = (is_array($errorBody) ? ($errorBody['message'] ?? json_encode($errorBody)) : $errorBody);
                throw new KycAuthenticationException(
                    "Authentication/Authorization failed with {$this->providerName}: " . $errorMessage,
                    $response->status(),
                    null,
                    is_array($errorBody) ? ($errorBody['error_code'] ?? (string) $response->status()) : (string) $response->status(),
                    $this->providerName
                );
            }
            return $response;
        } catch (\Illuminate\Http\Client\ConnectionException $e) {
            Log::error("{$this->providerName} KYC Connection Error (e.g., Timeout): " . $e->getMessage(), ['endpoint' => $endpoint, 'exception_trace' => $e->getTraceAsString()]);
            throw new KycConnectionException("Connection error or timeout with {$this->providerName}: " . $e->getMessage(), 0, $e, null, $this->providerName);
        } catch (KycAuthenticationException $e) {
            throw $e;
        } catch (\Exception $e) {
            Log::error("{$this->providerName} KYC Request Failed (General Exception): " . $e->getMessage(), ['endpoint' => $endpoint, 'exception_type' => get_class($e), 'exception_trace' => $e->getTraceAsString()]);
            throw new KycException("Request failed with {$this->providerName}: " . $e->getMessage(), $e->getCode() ?: 500, $e, null, $this->providerName);
        }
    }

    protected function processResponse(
        IlluminateResponse $response,
        ?callable $successCondition = null,
        ?callable $dataExtractor = null,
        ?callable $messageExtractor = null
    ): KycDriverResponse {
        $isSuccessful = $successCondition ? $successCondition($response) : $response->successful();
        $statusCode = $response->status();
        $rawBody = $response->body();
        
        $processedData = null;
        try {
            if ($dataExtractor) {
                $processedData = $dataExtractor($response);
            } else {
                $jsonAttempt = $response->json();
                if ($jsonAttempt !== null) {
                    $processedData = $jsonAttempt;
                }
            }
        } catch (\Exception $e) {
            Log::warning("{$this->providerName} KYC: Error during data extraction phase.", [
                'error_message' => $e->getMessage(),
                'error_file' => $e->getFile(),
                'error_line' => $e->getLine()
            ]);
        }

        $message = null;
        try {
            if ($messageExtractor) {
                $message = $messageExtractor($response, $isSuccessful);
            } elseif (!$isSuccessful) {
                $jsonForError = $processedData ?? $response->json();
                if (is_array($jsonForError)) {
                    $message = $jsonForError['message']
                        ?? $jsonForError['error_description']
                        ?? $jsonForError['error']
                        ?? $jsonForError['detail']
                        ?? (isset($jsonForError['errors']) && is_array($jsonForError['errors']) ? implode(', ', array_map(function($err) {
                                return is_array($err) ? ($err['message'] ?? json_encode($err)) : $err;
                            }, $jsonForError['errors'])) : null);
                    if (is_array($message)) $message = json_encode($message);
                }

                if ($message === null && is_string($rawBody) && !empty($rawBody)) {
                    if (strpos(strtolower($response->header('Content-Type') ?? ''), 'json') === false) {
                         $message = (strlen($rawBody) > 255) ? substr($rawBody, 0, 255) . "..." : $rawBody;
                    }
                }
                if ($message === null) {
                    $message = "{$this->providerName} request failed with status code {$statusCode}.";
                }
            } else { 
                 $message = "{$this->providerName} request was successful.";
            }
        } catch (\Exception $e) {
            Log::warning("{$this->providerName} KYC: Error extracting message from response.", ['error' => $e->getMessage()]);
            $message = "Error processing response message.";
        }

        return new KycDriverResponse(
            $isSuccessful,
            $statusCode,
            is_string($message) ? $message : json_encode($message),
            $rawBody,
            $processedData
        );
    }
}